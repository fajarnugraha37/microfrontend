<!--- This file is modeled after the stores-wiki documentation - it expands the Bus details, API and troubleshooting -->
# Microfrontends - Event & RPC Bus

This document describes the DOM-backed Event & RPC Bus used by microfrontends and the host inside this repository. It is intentionally thorough and designed to match the detail of the `stores-wiki.md` file:

- What components exist (DomEventBus, MfeEventBus, MicrofrontBus)
- Message formats and event naming conventions
- How RPC works under-the-hood (request/response, pending map, timeout)
- Internal implementation details and pointers (e.g., `pending`, `unsubscribers`)
- Examples to wire the host and microfrontend
- Troubleshooting and debugging
- Migration and decommission steps

> TL;DR: The bus is a DOM CustomEvent transport (uses `CustomEvent`) that provides both
> pub/sub events and two-way RPC semantics on top of it. It's lightweight, simple to inspect
> at runtime and ideal for communication across script bundles on the same document.

---

## Contents

- Overview
- Event Format & Naming
- Transport: `DomEventBus` (Detailed)
- Messaging & RPC: `MfeEventBus` (Detailed)
- High-level wrapper: `MicrofrontBus`
- Bundler & Singleton considerations
- Security, performance, and caveats
- Detailed API Reference
- Troubleshooting and FAQ
- Examples & Integration patterns (Host & MFE)
- Migration & Decommissioning guide
- Testing & Unit / Integration tests
- Appendix: Internal Implementation Notes

---

## Overview

The bus uses DOM CustomEvents and a friendly Typed API to ease communication between host and microfrontends (MFEs). It is intentionally *transport-focused* and not opinionated about message payloads.

Advantages:
- No cross-window postMessage serialization or iframes specific logic when used within the same document (e.g. host + MFE wrappers loaded into the same page).
- Easy to debug — open the browser devtools and listen for `CustomEvent` events.
- Provides a small RPC model, with request/response semantics.

Limitations:
- Scoped to the same document naturally — it does not cross subdomains or different domain frames unless explicitly wired.
- Not secure; other scripts on the page can listen to CustomEvents if they know event names / prefixes.

---

## Event Format & Naming Conventions

To keep event collisions minimal and improve readability, the bus uses the following naming conventions:

- Logical event names are prefixed with a `prefix` string. Example: `"aceas:"` + `evt:app:mounted`.
- One-way event names use the `evt:` prefix under the final event name. Example: `evt:myEvent` => `aceas:evt:myEvent`.
- RPC events are broadcast using two dedicated logical event names:
  - `__rpc:request` (for outgoing requests)
  - `__rpc:response` (for replies)

RPC Message shape — request:

```js
{ id: string, method: string, params: any }
```

RPC Message shape — response:

```js
// successful response
{ id: string, result: any }

// error response
{ id: string, error: { message: string } }
```

The `id` is a unique request identifier generated by the `MfeEventBus` / `MicrofrontBus` helper.

---

## Transport: `DomEventBus` (Detailed)

`DomEventBus` is a small wrapper around `EventTarget` + `CustomEvent` that implements:

- Automatic `prefix` management for event names
- `on`/`once`/`off` helpers and `unsubscribe` return patterns
- Internal listener registry so you can call `removeAllListeners` and `destroy`

Constructor options:
- `target`: EventTarget — usually `window` or `document` (required)
- `prefix` (string) — optional event name namespace prefix
- `bubbles`, `composed`, `cancelable` — control `CustomEventInit`

Important: `DomEventBus` checks that `target` exists and throws if used in a non-browser environment. For SSR or Node-style contexts you should avoid using the bus or make a platform-specific adapter.

Internal notes:
- The `on()` API wraps your supplied callback in an internal wrapper that ensures only `CustomEvent` is processed and avoids errors propagating outside the handler.
- The bus keeps a `Map<string, Set<Listener>>` with registered listeners so `removeAllListeners` can reliably clean up.

Example:

```js
import { DomEventBus } from 'mfe-components/src/bus/domEventBus';
const domBus = new DomEventBus(window, { prefix: 'aceas:'});

const unsub = domBus.on('my-event', (payload) => console.log(payload));
domBus.emit('my-event', { foo: 'bar' });
unsub();
domBus.destroy();
```

---

## Messaging & RPC: `MfeEventBus` (Detailed)

`MfeEventBus` is built on top of `DomEventBus` and provides two main sets of functionality:

1) One-way pub/sub using `evt:` logical event names.
2) Two-way RPC using `request`/`handle` methods talking over `__rpc:request`/`__rpc:response` logical events.

### RPC lifecycle & pending map

`MfeEventBus` implements an internal `pending` map to correlate requests and responses.
Each RPC `request`:
- generates a `requestId` (string)
- stores a `pending` entry: `{ resolve, reject, timeoutId }` under that id
- emits a `__rpc:request` event with `{ id, method, params }`
- waits for `__rpc:response` with matching `id` and then resolves or rejects the promise

If timeout occurs, the pending entry is rejected and removed.

If the recipient throws, the `handle` wrapper catches and emits an error response.

### Handler registration and collision behavior

`handle(method, handler)` registers a method handler. The implementation will:
- log a warning if you call `handle` for the same method twice (it will override the previous handler)
- return an `unregister()` function to remove the handler

Important behavior notes:
- Only the first handler that matches will respond — any `request` is broadcast on the page. If multiple handlers for the same method exist across contexts they will respond in the order the event system decides — usually first-installed handler will win (but this is implementation detail of the runtime — avoid duplicate registrations).
- `request` does not guarantee a single listener will respond; any listener can respond.

### Debugging & logging

You can enable `debug` to produce logs on `request`, `response`, `onEvent`/`emitEvent`, and handler registration. This helps when debugging a host <-> MFE flow.

---

## High-level wrapper: `MicrofrontBus`

The `MicrofrontBus` is a thin wrapper that builds the RPC and event model on top of `DomEventBus` but with a slightly smaller surface area meant for the shared singletons used across MFEs.

Key differences:
- `MicrofrontBus` uses `DomEventBus` internally and provides the same request/response mechanics.
- You can instantiate multiple `MicrofrontBus` instances but prefer the shared singleton exported from `src/bus/index.js`.

---

## Bundler & Singleton Considerations (Important)

Using the shared `bus`/`mfeEventBus` singletons is the typical approach. However when bundling MFEs you must ensure they *share the same copy of the package* to avoid duplicate singletons and unexpected message isolation.

Typical Strategies:
- In Webpack Module Federation: declare `mfe-components` as `singleton` or `shared` to ensure a single copy.
- In external script loading scenarios: attach `bus` to `window` yourself, and have every MFE `import` or reference the shared global.
- If using node-style ESM/CJS duplication: check `npm dedupe`/`pnpm` deduplication to avoid multiple copies.

If multiple copies are loaded, each will create their own `window`-attached instance and they will not share registered listeners or pending map state.

---

## Security & Performance

Security:
- Do not send credentials or secrets across the bus unless you're confident the page is trusted — CustomEvents are available to any code running in the same page.
- Prefix names consistently to avoid accidental collisions with 3rd party libraries.

Performance:
- Keep payload sizes small and avoid sending ultra-frequent high-volume messages.
- If you need cross-tab messaging (not covered by CustomEvent), consider `BroadcastChannel` or `localStorage` as a transport but be mindful of serialization and listener echo control.
- Avoid cyclical patterns where a message causes a reaction in another context that triggers the same message back — add proper deduplication or origin ID filtering where needed.

---

## API Reference (Detailed)

### DomEventBus

```
new DomEventBus(target: EventTarget, options?: {
  prefix?: string,
  bubbles?: boolean,
  composed?: boolean,
  cancelable?: boolean
});

on(type: string, handler: (detail, ev?: CustomEvent) => void, options?): () => void
once(type: string, handler: (detail, ev?: CustomEvent) => void, options?): () => void
off(type: string, listener: EventListener, options?): void
emit(type: string, detail?: any, init?: CustomEventInit): void
removeAllListeners(type?: string): void
destroy(): void
```

Key notes:
- The `type` passed to these methods is **without** prefix — the bus applies the prefix via options passed to the constructor.
- `on` returns an unsubscribe function; always call it — or call `removeAllListeners`.

### MfeEventBus / MicrofrontBus

```
new MfeEventBus(target: EventTarget, options?: {
  prefix?: string,
  defaultTimeout?: number,
  debug?: boolean,
  bubbles?: boolean,
  composed?: boolean,
  cancelable?: boolean
})

// events
onEvent(eventName: string, handler: (payload: any) => void): () => void
onceEvent(eventName: string, handler: (payload: any) => void): () => void
emitEvent(eventName: string, payload?: any): void

// RPC
handle(method: string, handler: (params: any) => Promise<any> | any): () => void
request(method: string, params?: any, options?: { timeout?: number }): Promise<any>
destroy(): void
```

Behavioral details:
- `onEvent('foo', handler)` listens on `evt:foo`.
- `handle('myMethod', handler)` registers the function to respond to RPC calls. The registered handler should either return a result or throw/throw Error to return an `error` to the client.
- `request` returns a `Promise` that resolves with value or rejects with a timeout or error object.

---

## Troubleshooting & FAQ (Detailed)

Check this list if you see messages not received, RPC timeouts, or odd behavior.

1) No handler / RPC returns no result
- Verify that `handle('methodName', ...)` exists on some context (host or MFE) and was registered before the request occurs. The handler must be installed before the `request` call.
- Confirm the prefixes match (e.g., both sides used `'aceas:'` prefix).

2) RPC Times out
- Verify handler is registered correctly and returns a value or resolves its Promise.
- Increase the `defaultTimeout` or set `{ timeout: 20000 }` in the `request` call if the handler performs network-bound or long-running processing.

3) Duplicate singletons / none of the listeners fire
- If the host logs show `window.bus` !== the MFE's `window.bus`, then bundlers created multiple copies. Ensure the bus package resolves to a single module / instance across the host & MFEs (Module Federation or shared packages).

4) Messages don't cross iframe boundaries
- `CustomEvent`s are scoped to the same document; events in frames do not propagate across domains or separate windows automatically. If you need cross-document communication you must the `postMessage` API or other transports. For same-domain frames the event might be accessible depending on the environment but you should test thoroughly.

5) `destroy` rejects pending RPCs
- If the bus is destroyed while there are pending RPCs, the internal `pending` entries will be rejected due to cleanup — that's expected; ensure you `unregister` handlers and `destroy()` bus only while your app is tearing down.

---

## Examples & Integration Patterns (Host & MFE)

### Host (example)

```js
// host/main.js
import { bus } from 'mfe-components';

// add a handler on the host to satisfy MFE requests
bus.handle('host:getUser', async ({ id }) => {
    const user = await fetch(`/api/users/${id}`).then(r => r.json());
    return user;
});

// host listens for events
bus.onEvent('mfe:loaded', (payload) => {
  console.log('MFE loaded', payload);
});
```

### MFE (example)

```js
// mfe/main.js
import { bus } from 'mfe-components';

// request user details from host
async function showUser(id) {
  try {
    const user = await bus.request('host:getUser', { id });
    console.log('user', user);
  } catch (err) {
    console.error('RPC error', err);
  }
}

// publish an event
bus.emitEvent('mfe:loaded', { mfeName: 'cart' });
```

### Cross-tab / Broadcast scenarios (optional)

`DomEventBus` uses `CustomEvent` for the current document. If you need cross-tab sync, add a `BroadcastChannel` or `localStorage` adapter on top of the `DomEventBus` or create a `CrossTabBus` wrapper that translates events into `BroadcastChannel` messages and re-emits them onto the `DomEventBus` target. This repository does not automatically do cross-tab broadcast by default — it's intentionally in a separate helper if you want to enable it.

---

## Migration & Decommissioning Guide

When migrating away from this bus or consolidating an event-based system to a shared store / API:

1. Stage: Convert RPC methods to host APIs or a shared store API.
2. Replace critical handlers with direct module imports or HTTP calls on the host.
3. Reduce usage of `bus` gradually (mark deprecated methods), and publish a new minor version that logs deprecation warnings.
4. Remove the `bus` usage completely and then delete the shared bus package once all consumers stop importing it.

---

## Testing & Unit / Integration Tests

Suggested tests for a robust pipeline:

- Unit tests for `DomEventBus` — verify `on/once/off/emit/removeAllListeners/destroy` behavior including edge cases (handler throws, not a CustomEvent, double off calls).
- Unit tests for `MfeEventBus` — verify `handle` registration/unregistration, `request` resolves on successful response, rejects on timeout or handler throwing.
- Integration tests: host and MFE in a same-page environment where the test installs a `MfeEventBus` and `MicrofrontBus` and runs real `request` and `emitEvent` commands.
- Cross-tab smoke test: use two separate windows or frames (same domain) to test `BroadcastChannel`/`localStorage` adapters if you wire them.

Manual test harness (quick):
1. Build `dist/mfe-components.umd.js`
2. Serve a static HTML that loads it and runs a script that includes two simple frames (host & mfe) to test cross-frame behavior.

---

## Appendix: Internal Implementation Notes

- `MfeEventBus` uses a small `createRequestId()` util to make a reasonably-unique ID string using `Date.now()` + random hex. The pending map stores `{ resolve, reject, timeoutId }`.
- `MfeEventBus` uses an internal `Set` of unsubscribers to clear listeners on `destroy`.
- For `DomEventBus`, the `on` method wraps a provided handler with a typed `EventListener` and stores the wrapper to `listeners` set so that `off` can properly unsubscribe.
- `MicrofrontBus` wraps/instantiates `DomEventBus` and uses the same event name mapping conventions as `MfeEventBus`.

---

## Final Checklist & Best Practices (short)

- Keep the bus usage small and scoped to event-only interactions and simple RPC calls for host-critical logic.
- Avoid broadcasting secrets, keep payloads minimal, use typed RPC method names if you can.
- Prefer the shared `bus` singleton across host and MFEs and configure bundlers to dedupe shared modules.
- Add `unregister()` calls for every `handle` registration and use the returned `unsubscribe` from `onEvent` to avoid leaks.

---

If you'd like, I can also:
- Add a small example under `examples/` illustrating host-MFE RPC + event exchange and a cross-tab BroadcastChannel adapter.
- Add typed TypeScript examples and re-export bus classes from the package root so they can be imported directly.

Document last modified: automated
# Microfrontends - Bus System

This document covers the DOM transport-backed event & RPC bus used in this microfrontend project. It includes the low-level `DomEventBus`, the `MfeEventBus` message/RPC layer, and the higher-level `MicrofrontBus` helper. There are examples for host and MFE usage, migration tips, troubleshooting, and recommended best practices.

---

## Overview

- The bus is implemented on top of the DOM CustomEvent system to simplify communication between the host and microfrontends (MFEs) in a page (browsers only).
- The implementation aims to be easy-to-use, with both one-way publish/subscribe events and a two-way RPC model.
- The `DomEventBus` is the minimal transport layer; `MfeEventBus` adds RPC and a rich API; `MicrofrontBus` wraps `DomEventBus` for a simpler interface and is used by the shared singleton `bus`.
- A shared singleton bus is exported from the package root: `bus` (MicrofrontBus) and `mfeEventBus` (MfeEventBus).

> Note: The bus is intended for browser environments. On SSR or non-browser environments, it will throw an error if you attempt to access `window` or the singleton instance.

---

## Architecture

- The bus uses `CustomEvent`s on an `EventTarget` (usually `window`) as the transport. Because DOM events are naturally broadcast on a page, this makes the bus ideal for communication between independent script bundles (MFEs & host).
- The `DomEventBus` handles prefixing, subscription management, and safe dispatching.
- `MfeEventBus` implements two models on top of `DomEventBus`:
    - One-way events (publish/subscribe) with event names like `evt:someEventName`.
    - Two-way RPC using request/response events with internal `__rpc:request` and `__rpc:response` logical event types, with a cross-tab friendly ID to correlate request/response.
- `MicrofrontBus` uses `DomEventBus` to expose a simpler API that still supports RPC and events.

### Singletons

In the package, you will find an `index.js` that exports a shared instance of `MicrofrontBus` and `MfeEventBus` as:

```js
import { bus, mfeEventBus } from 'mfe-components';
```

These are created using the current `window` as the transport target and are attached to `window` to make them available to other bundles. Bundlers should be configured to treat the module that creates these singletons as a single instance across your MFEs.

---

## Transport: `DomEventBus`

`DomEventBus` is a minimal typed wrapper around `EventTarget`/`CustomEvent` built to:
- Add a consistent `prefix` to event names
- Provide subscribe (`on`, `once`) and unsubscribe (`off`) helpers
- Hold a list of active listeners and provide `removeAllListeners` and `destroy`

Example:

```js
import { DomEventBus } from 'mfe-components/src/bus/domEventBus';

const domBus = new DomEventBus(window, { prefix: 'aceas:', bubbles: false });

const unsubscribe = domBus.on('some-type', (payload, ev) => {
  console.log('payload', payload);
});

domBus.emit('some-type', { value: 123 });
// later
unsubscribe();
// or
// domBus.removeAllListeners('some-type');

// clean up resources
domBus.destroy();
```

Key methods/signatures
- `constructor(target, options)` - requires a target (e.g., `window` or `document`)
- `.on(type, handler, options)` - returns an unsubscribe function
- `.once(type, handler, options)` - one-time handler
- `.off(type, listener, options)` - remove a specific handler
- `.emit(type, detail, init)` - dispatches a `CustomEvent`
- `.removeAllListeners(type?)` - remove all or specific listeners
- `.destroy()` - remove all and null target

Use this when you want a tiny custom transport without RPC.

---

## Message & RPC: `MfeEventBus`

`MfeEventBus` builds RPC and event mechanics on top of `DomEventBus` and exposes a higher-level API:
- One-way events: `onEvent`, `onceEvent`, `emitEvent`.
- Two-way RPC: `handle` and `request` (with timeout handling and error responses).
- Keep in mind that RPC messages use `__rpc:request` and `__rpc:response` logical names under the prefix, encoded as `{ id, method, params }` for requests and `{ id, result, error }` for responses.

Quick example:

```js
import { MfeEventBus } from 'mfe-components/src/bus/mfeEventBus';
const mfeBus = new MfeEventBus(window, { prefix: 'aceas:', defaultTimeout: 5000, debug: true });

// Register RPC handler
const unregister = mfeBus.handle('host:getUser', async ({ userId }) => {
  return await fetchUserDetails(userId);
});

// Make RPC call from an MFE or host
mfeBus.request('host:getUser', { userId: '123' }).then(user => {
  console.log('user', user);
}).catch(err => console.error('RPC error', err));

// send one-way events
mfeBus.emitEvent('app:mounted', { time: Date.now() });

// subscribe to events
const unsub = mfeBus.onEvent('app:mounted', (payload) => console.log('mounted', payload));

// cleanup
unregister();
unsub();
mfeBus.destroy();
```

Key notes
- `handle(method, handler)` returns an unregister function.
- `request(method, params, { timeout })` returns a `Promise`; it rejects if there's no handler or the call times out.
- RPC requests are broadcast on `__rpc:request`; any matching handler should return a result or throw to respond with error.
- The bus preserves the `prefix` for event names; make sure both sides use the same prefix or use the shared singleton.

---

## `MicrofrontBus` (High-level wrapper)

`MicrofrontBus` is a convenience wrapper that implements the same semantics built from `DomEventBus` and exposes a subset of `MfeEventBus` semantics (one-way events + RPC):

Example:

```js
import { MicrofrontBus, bus } from 'mfe-components';

// You can instantiate a local instance or use the provided singleton
const localBus = new MicrofrontBus(window, { prefix: 'aceas:' });

bus.handle('getState', () => ({ ok: true }));

bus.request('getState').then(s => console.log('state', s));
```

`MicrofrontBus` uses the same `__rpc:request`/`__rpc:response` event naming for RPC and `evt:` prefixing for events.

---

## Exported singletons and bundler considerations

- The repository exports a shared `bus` (`MicrofrontBus`) and `mfeEventBus` (`MfeEventBus`) in `src/bus/index.js`. These are attached to `window` as well: `window.bus` and `window.mfeEventBus`.
- When you consume these in host and MFE bundles, ensure your bundler treats the bus module as a singleton (e.g., by making it an external in a microfrontend bundling strategy or by preventing duplicate module copies via package manager deduplication and shared dependency configuration).
- If you have multiple copies of the bus module because of dependency mismatches, each copy will create its own `window` instance; this defeats the purpose of a shared transport.

---

## Best practices

- Use a unique `prefix` when constructing a bus (e.g., `aceas:`) so your events don't collide with vendor code.
- Use `handle()` registration only for specific handler names and avoid dynamically named handlers that may collide.
- Use the `debug` option while developing to log traffic.
- Use `onceEvent` for listeners that should fire only once; always keep references to unsub functions and call them on cleanup.
- For long-lived handlers, ensure you `unregister` them during teardown to avoid memory leaks.
- Ensure you only call the bus API from browser contexts (not SSR) — the `index.js` singleton will throw a clear error if run outside a browser.

---

## Troubleshooting & Common Errors

1. "No handler for method"
   - Cause: You called `request` but no side installed a handler for the named method.
   - Fix: Verify `handle('methodName', ...)` was registered on the receiving side and the names (and prefixes) match.

2. RPC Timeout
   - Cause: The handler did not respond in the expected time window or handler threw an error.
   - Fix: Increase `defaultTimeout` or pass `{ timeout }` to `request`. Confirm handler completes and returns a value or throws with a message.

3. Duplicate instances (no broadcast)
   - Cause: Duplicate copies of the bus module (bundler created multiple copies) or wrong target usage.
   - Fix: Ensure bundler configuration yields a single instance (treat as shared/external), and verify `window.bus` exists in console and is the same object across contexts.

4. Unhandled rejections/`bus.destroy` issued without cleanup
   - Cause: Destroying the bus while there are pending RPCs can lead to rejections; cleanup all handlers and pending calls.
   - Fix: Unregister handlers, `clearTimeout` if your code tracks timeouts, and handle bus `destroy` gracefully where you use it.

5. Prefix mismatch
   - Cause: Host uses `prefix: 'aceas:'` but MFE uses `prefix: 'others:'`.
   - Fix: Use the same `prefix` or use the shared singleton to avoid prefix mismatch.

6. SSR/Non-browser errors
   - Cause: Attempting to use `window` or the singleton in a non-browser environment.
   - Fix: Only access the bus under `if (typeof window !== 'undefined')` or provide a platform-specific fallback.

---

## Migration / Integration guide

- For host-side integration
  - Import the `bus` or `mfeEventBus` provided by the package or instantiate your own if preferred.
  - Register handlers on the host to implement RPC.
  - Ensure you attach `bus` to `window` only once and your bundler treats it as a single bundle shared across MFEs.

- For MFE-side integration
  - Use the shared bus (`bus`) from the package root (imported or `window.bus`) to send events to the host and other MFEs.
  - Use `handle` to respond to requests from the host or other MFEs.

---

## Example: Host registers a handler, MFE calls it

Host:
```js
import { bus } from 'mfe-components';

bus.handle('getUser', async ({ id }) => {
  return fetchUserFromServer(id);
});
```

MFE:
```js
import { bus } from 'mfe-components';

bus.request('getUser', { id: '123' }).then(user => console.log(user));
```

---

## API Reference (quick)

DomEventBus
- `constructor(target, { prefix?, bubbles?, composed?, cancelable? })`
- `on(type, handler, options): () => void`
- `once(type, handler, options): () => void`
- `off(type, listener, options): void`
- `emit(type, detail, init): void`
- `removeAllListeners(type?): void`
- `destroy(): void`

MfeEventBus
- `constructor(target, { prefix?, defaultTimeout?, debug?, bubbles?, composed?, cancelable? })`
- `onEvent(eventName, handler): () => void`
- `onceEvent(eventName, handler): () => void`
- `emitEvent(eventName, payload): void`
- `handle(method, handler): () => void`
- `request(method, params, { timeout? }): Promise<any>`
- `destroy(): void`

MicrofrontBus
- Same as MfeEventBus but built as a light wrapper using `DomEventBus` under the hood.

---

## Security & Performance Considerations

- Don't broadcast secrets on public events; the bus broadcasts on the page and any script with access to the DOM can listen.
- Keep payloads lightweight to avoid heavy serialization overhead on the main thread.
- Avoid infinite or large fan-out events in the render path — prefer simply structured messages.
- Use `prefix` namespacing, and avoid global names that collide with other scripts.

---

## Testing

- You can test the bus in a simple HTML page by importing the built `dist/mfe-components.umd.js` and opening two separate frames that both load the built bundle. They will listen to each other's `window` events if the frame’s window allows cross-frame event propagation.
- For RPC, register a handler in one frame and call `.request()` in the other. Verify that the `request` resolves and timing out or error-handling is well-behaved.

---

## FAQ

Q: Can I use JSON-serializable payloads only?
A: Not strictly required — `CustomEvent` can carry object references in the same page, but avoid non-serializable values if your transport can cross iframe boundaries or be used with postMessage in the future.

Q: Does the bus transmit across domains?
A: Only if a cross-document or postMessage transport is used. The DOM `CustomEvent` approach is scoped to the current document and works between bundles loaded in it.

---

## References & Further Reading

- Usage patterns: check `src/bus/index.js` for the shared singleton usage
- Files: `src/bus/domEventBus.js`, `src/bus/mfeEventBus.js`, `src/bus/microfrontBus.js`

---

If you want, I can also add small test pages under `examples` to demonstrate cross-tab RPC and event usage, or add TypeScript examples for stronger typing on the RPC methods.

---

Document last modified: (generated)
